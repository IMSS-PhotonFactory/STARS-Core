#! /usr/bin/perl
use strict;
use Getopt::Long;
use stars;
#################################################################
# shot102 STARS client
# $Revision: 1.1 $';
# $Date: 2010/01/19 01:55:15 $;
# 2010-06-18 Yasuko Nagatani
# Update	yyyy-mm-dd	Description
# Program Internal Parameters : Do not change.
$::Version = '1.0';
$::DeviceType='SHOT102';
@::InternalChannelName = ('A','B');
use constant WAIT_MEMWRITE       =>   10;   # Wait for  Write to memories.
use constant WAIT_MEMWRITE_HOLD  =>   80;   # Wait for  Write to memories.
use constant INTERVAL_STOP  => 2000;
use constant INTERVAL_RUN   =>  100;
use constant REFRESH_RUN    =>  500;
#################################################################
## Initialize Program Internal Parameters : Never change.
#$::Test=1;
$::StartupCheckLimitAdjust=0;
$::SyncFailSafeWithLimit=1;
$::IsNoReply  = 0;
$::IsScanHome = 0;
$::IsScanHomeManual = 0;
$::ScanHomeDirection	= -1;
$::ConfigAutoHoldoffEnableWhenIsNotBusy='';
%::Settings=();
$::ClearStandByModeFlg=0;
%::Flg_Busy=();								# For Handle Busy or not
%::Current=();								# Store Current Value
%::Flg_LimitSwitchOn=();					# For Handle Limit Switch
%::MotorName=();
$::SyncRunCommandBuffer='';
%::SyncRunParameterBuffer=();
$::Settings{'AutoHoldOnOffW'}=0;
%::ChannelMax=();
%::ChannelMin=();
%::FailSafeMax=();
%::FailSafeMin=();
%::FailSafeStop=();
$::SpeedAccTime=();
%::FunctionParameters=();
foreach my $ch (@::InternalChannelName){
	$::Settings{'AutoHoldOnOff'.$ch}=0;
	$::Flg_Busy{$ch} = '';
	$::Current{$ch} = '';
	$::Flg_LimitSwitchOn{$ch} = '';
	$::SyncRunParameterBuffer{$ch}='';
}
$::CtlIsStandBy = 0;
%::helpcntrl=();
$|=1;
set_help_list();
$::Enableinterval=0;
#################################################################
## ToDo: Set parameters here.
$::Server     = 'localhost';        #Default stars server.
$::Debug      = '';
#################################################################

## ToDo: You can set option switchs. See help 'Getopt::Long'.
GetOptions(
'd'        => \$::Debug,
'h'        => \&usage,
) or die "Bad switch.\n";

if($_ = shift(@ARGV)){$::NodeName = $_;}
require 'config.pl';
for(my $i=0; $i<=$#::InternalChannelName; $i++){
	if($::Debug){print "Set ",$::MotorName[$i],"<=",$i,"\n";}
	$::MotorName{$::MotorName[$i]}=$i;
	if(defined($::ConfigLimitMaximum{$::MotorName[$i]})){
		$::ChannelMax{$::InternalChannelName[$i]}=$::ConfigLimitMaximum{$::MotorName[$i]};
	}else{
		$::ChannelMax{$::InternalChannelName[$i]}=16777214;
	}
	if(defined($::ConfigLimitMinimum{$::MotorName[$i]})){
		$::ChannelMin{$::InternalChannelName[$i]}=$::ConfigLimitMinimum{$::MotorName[$i]};
	}else{
		$::ChannelMin{$::InternalChannelName[$i]}=-16777214;
	}
	if($::SyncFailSafeWithLimit){
		$::FailSafeMax{$::InternalChannelName[$i]}=$::ChannelMax{$::InternalChannelName[$i]};
	}elsif(defined($::ConfigFailsafeMaximum{$::MotorName[$i]})){
		$::FailSafeMax{$::InternalChannelName[$i]}=$::ConfigFailsafeMaximum{$::MotorName[$i]};
	}else{
		$::FailSafeMax{$::InternalChannelName[$i]}=$::ChannelMax{$::InternalChannelName[$i]};
	}
	if($::SyncFailSafeWithLimit){
		$::FailSafeMin{$::InternalChannelName[$i]}=$::ChannelMin{$::InternalChannelName[$i]};
	}elsif(defined($::ConfigFailsafeMinimum{$::MotorName[$i]})){
		$::FailSafeMin{$::InternalChannelName[$i]}=$::ConfigFailsafeMinimum{$::MotorName[$i]};
	}else{
		$::FailSafeMin{$::InternalChannelName[$i]}=$::ChannelMin{$::InternalChannelName[$i]};
	}
	$::FailSafeStop{$::InternalChannelName[$i]}=0;
	
	if(defined($::ConfigSpeedAccTime{$::MotorName[$i]})){
		$::SpeedAccTime{$::InternalChannelName[$i]}=$::ConfigSpeedAccTime{$::MotorName[$i]};
		if($::ConfigSpeedAccTime{$::MotorName[$i]}!~/^(\S+),(\S+),(\S+)$/){
			die "$::ConfigSpeedAccTime{$::MotorName[$i]}: value format is '<low speed>,<high speed>,<acc time>'\n";
		}
	}else{
		$::SpeedAccTime{$::InternalChannelName[$i]}="Depending on controller settings.";
	}
}
if($::ConfigAutoHoldoffEnableWhenIsNotBusy){
	$::Settings{'AutoHoldOnOffW'}=1;
	foreach my $ch (@::InternalChannelName){
		$::Settings{'AutoHoldOnOff'.$ch}=1;
	}
}
################################################################
# Interface library
# Prease include your own interface library.
# "device_read", "device_write" and "device_init" must be included
# in the library.
require 'nportsvr.pl';    #For nport server
################################################################
## Init device
device_init();

unless(device_write('?:V')){die "Could not connect $::DeviceType\n";}
$::RomVersion=device_read();
if($::Test){$::RomVersion='test111';}
if($::RomVersion eq ''){
	die "Failure to Get RomVersion. Please restart $::NodeName.\n";
}

## Open Stars server. $::tak is a Stars object.
$::tak = stars->new($::NodeName, $::Server)
	or die "Could not connect Stars server";
if($::Debug){print "Started with debug mode.\n";}

$::Buf_Interval = 0;
if(C_Stop('W') eq ''){die $::Error,"\n";}
sigma_flushdata('System');
$::Interval_Time = INTERVAL_STOP;
EnableInterval();
EnableIntervalRun();
for(my $i=0; $i<=$#::InternalChannelName; $i++){
	my $chX=$::InternalChannelName[$i];
	if($::SpeedAccTime{$chX}=~/^(\S+),(\S+),(\S+)$/){
		if($::Debug){print $::SpeedAccTime{$chX},"\n";}
		if(C_SetSpeedAccTime($chX,$1,$2,$3) eq ''){die $::Error,"\n";}
	}
}
for(my $i=0; $i<=$#::InternalChannelName; $i++){
	my $chX=$::InternalChannelName[$i];
	if($::Debug){print $::Flg_Busy{$chX},"\n";}
	unless($::Flg_Busy{$chX} eq ''){next;}
	#Limit detected
	if(($::StartupCheckLimitAdjust) and (C_GetLimitStatus($chX) eq '0')){
		my $savecurrent=$::Current{$chX};
		if($savecurrent<0){
			unless(M_Jog($i,1) eq 'Ok:'){print $::Error,"\n";next;}
			while(C_IsBusy($chX)){
				EnableInterval();EnableIntervalRun();
			}
			if($savecurrent ne $::Current{$chX}){
				C_SetForceLimitStatus($chX,-1);
				print "Ccw limit detected.","\n";next;
			}
			unless(M_Jog($i,-1) eq 'Ok:'){print $::Error,"\n";next;}
			while(C_IsBusy($chX)){
				EnableInterval();EnableIntervalRun();
			}
			if($savecurrent ne $::Current{$chX}){
				C_SetForceLimitStatus($chX,1);
				print "Cw limit detected.","\n";next;
			}
			print "Limit detected, but not knowing Cw/Ccw.","\n";
		}else{
			unless(M_Jog($i,-1) eq 'Ok:'){print $::Error,"\n";next;}
			while(C_IsBusy($chX)){
				EnableInterval();EnableIntervalRun();
			}
			if($savecurrent ne $::Current{$chX}){
				C_SetForceLimitStatus($chX,1);
				print "Cw limit detected.","\n";next;
			}
			unless(M_Jog($i,1) eq 'Ok:'){print $::Error,"\n";next;}
			while(C_IsBusy($chX)){
				EnableInterval();EnableIntervalRun();
			}
			if($savecurrent ne $::Current{$chX}){
				C_SetForceLimitStatus($chX,-1);
				print "Ccw limit detected.","\n";next;
			}
			print "Limit detected, but not knowing Cw/Ccw.","\n";
		}
	}
}
$::tak->addcallback(\&handler);
if($::Test){
	stars->Mainloop();
}else{
	stars->Mainloop(\&interval, \$::Interval_Time);
}
exit(1);

# Print usage. ---------------------------------------------
sub usage{
## Todo: Please modify help message for "-h" option.
  print "Usage: $::NodeName [-h] [-d] MyNodeName\n";
  exit(0);
}
#=====for internal=============================================
sub sigma_disconnect{
	return('QuitControl');
}

#############################################################
## handler called by Stars Server
#############################################################
sub handler{
## ToDo: Please modify handler sub routine.
##  (The handler sub routine will be called when client
##  receives a message from a Stars server.)
	my ($from, $to, $mess) = @_;
	my $rt='';

	if($::Debug){print "STARS RCV: $from>$to $mess\n";}
##Ignore Event/Reply Messages ##
	if($mess=~/^[_@]/){return;}
## Motor Commands ##
	if($to=~/^$::NodeName\.([^\.\s]+)$/){
	 	$_=name2num($1);
	 	if($_>=0){$rt = M_handler($from, $to, $_, $mess);
	 	}else{$::tak->Send("\@$mess Er: $to is down.", $from);return;}
## Controller Commands ##
	}elsif($to=~/^$::NodeName$/){
		$rt = C_handler($from, $to, $mess);
## Bad Device Name ##
	}else{
		$::tak->Send("\@$mess Er: $to is down.", $from);return;
	}
## Response ##
	if($rt eq ''){
		$::tak->Send("$to>$from \@$mess Er: $::Error");
		if($::Debug){print "STARS SND: $to>$from \@$mess Er: $::Error\n";}
	}else{
		$::tak->Send("$to>$from \@$mess $rt"); 
		if($::Debug){print "STARS SND: $to>$from \@$mess $rt\n";}
	}
	EnableIntervalRun();
	return;
}
#############################################################
## C_handler called by handler
#############################################################
sub C_handler{
	my ($from, $to, $mess) = @_;
	my $rt='';
	my($target,$cmd);

## Controller commands ##
	if($mess eq 'hello')				{$rt='nice to meet you.';
	}elsif($mess eq 'help')				{$rt=get_help_list('Cntrl');
	}elsif($mess=~/^help\s+(\S+)/)		{$rt=get_help_list('Cntrl', $1);
	}elsif($mess=~/^getversion$/)		{$rt=$::Version;
	}elsif($mess=~/^GetRomVersion$/)	{$rt=$::RomVersion;
	}elsif($mess=~/^GetMotorList$/)		{$rt=join(" ", @::MotorName);
	}elsif($mess=~/^GetMotorName\s(\d)$/){$rt=num2name($1);
	}elsif($mess=~/^GetFunctionStatus$/){$rt=C_GetFunctionStatus();
	}elsif($mess=~/^Standby$/)			{$rt=C_Standby(1);
	}elsif($mess=~/^Standby\s+([01])$/)	{$rt=C_Standby($1);
	}elsif($mess=~/^SyncRun$/)			{$rt=C_SyncRun();
	}elsif($mess=~/^Stop$/)				{$rt=C_Stop('W');
	}elsif($mess=~/^StopEmergency$/)	{$rt=C_Stop_Emergency();
	}elsif($mess=~/^flushdata$/)		{$rt=sigma_flushdata();EnableInterval();
	}elsif($mess=~/^flushdatatome$/)	{$rt=sigma_flushdata($from);EnableInterval();
	}elsif($mess=~/^SetScanHomeManualFlg\s+([01])$/){$::IsScanHomeManual=$1;$rt='Ok:';
	}elsif($mess=~/^GetScanHomeManualFlg$/)		{$rt=$::IsScanHomeManual;
	}elsif($mess=~/^IsNoReply$/)		{$rt=$::IsNoReply;
	}elsif($mess=~/^IsStandby$/)		{$rt=Is_Standby();
	}elsif($mess=~/^test\sread/)		{$rt=device_read();
	}elsif($mess=~/^test\s(.+)$/)		{if(device_write($1)){$rt='Ok:';}
	}elsif($mess=~/^DebugShowIntervalTime$/)	{$rt=$::Interval_Time;
	}elsif($mess=~/^DebugShowSyncRunBuffer$/){$rt=C_ShowSyncRunBuffer();
	}elsif($mess=~/^(\S+)\s+(\S+)\s*(.*)$/){
		if($3 eq ''){$cmd=$1}else{$cmd="$1 $3"}
		$target=$2;
		$_=name2num($target);
		if($_>=0){
			$rt=M_handler($from, $to, $_, $cmd);
		}elsif($target=~/^(\d)$/ and (($target+0)<=$#::InternalChannelName)){
			$rt=M_handler($from, $to, $target, $cmd);
		}else{
			$::Error="Bad command or parameter";
		}
	}else{
		$::Error = "Bad command or parameter";
		if($::Debug){print "Controller $::Error:$from,$to,$mess,#$rt#\n";}
	}
	return($rt);
}
#############################################################
## Channel_handler called by handler
#############################################################
sub M_handler{
	my ($from, $to, $target, $cmd) = @_;
	my $rt='';
#--------------------------------------------------
# M_Commands
#--------------------------------------------------
	if($::Debug){print "MotorHdlr RCV: $from>$to $target $cmd\n";}
	if($cmd eq 'hello')				{$rt='nice to meet you.';
	}elsif($cmd eq 'help')			{$rt=get_help_list(num2name($target));
	}elsif($cmd=~/^help\s+(\S+)/)	{$rt=get_help_list(num2name($target),$1);
	}elsif($cmd=~/^GetMotorNumber$/){$rt=$target;
	}elsif($cmd=~/^IsBusy$/)        {$rt=M_IsBusy($target);	EnableInterval();
	}elsif($cmd=~/^Stop$/)         	{$rt=M_Stop($target);
	}elsif($cmd=~/^StopEmergency$/) {
		$::Error='Sorry. Emergency stop is supported for controller only.';
	}elsif($cmd=~/^GetValue$/)		{$rt=M_GetValue($target);EnableInterval();
	}elsif($cmd=~/^SetValue\s(-*\d+)$/){
		unless($rt=M_SetValue($target, $1)){clear_syncrunbuffer();}
	}elsif($cmd=~/^SetValueREL\s(-*\d+)$/){
		unless($rt=M_SetValueREL($target, $1)){clear_syncrunbuffer();}
	}elsif($cmd=~/^GetSpeedAccTime$/)	{$rt=$::SpeedAccTime{mn2chX($target)};
	}elsif($cmd=~/^SetSpeedAccTime\s+(\d+),(\d+),(\d+)$/) {
		my $param="$1,$2,$3";
		if(($rt=M_SetSpeedAccTime($target,$1,$2,$3))){
			$::SpeedAccTime{mn2chX($target)}="$param";
		}
	}elsif($cmd=~/^Preset\s+(0+)$/)		{$rt=M_Preset($target, $1);
	}elsif($cmd=~/^SetHold\s([0|1])$/)	{$rt=M_SetHold($target,$1);
	}elsif($cmd=~/^JogCw$/)				{$rt=M_Jog($target,1);
	}elsif($cmd=~/^JogCcw$/)			{$rt=M_Jog($target,-1);
	}elsif($cmd=~/^ScanCw(Const)?$/)	{$rt=M_ScanConst($target,'+');
	}elsif($cmd=~/^ScanCcw(Const)?$/)	{$rt=M_ScanConst($target,'-');
	}elsif($cmd=~/^ScanCwHome$/)		{$rt=M_ScanHome($target,"+");
	}elsif($cmd=~/^ScanCcwHome$/)		{$rt=M_ScanHome($target,"-");
	}elsif($cmd=~/^ScanHome$/ and $::ScanHomeDirection<0){$rt=M_ScanHome($target,"-");
	}elsif($cmd=~/^ScanHome$/ and $::ScanHomeDirection>0){$rt=M_ScanHome($target,"+");
	}elsif($cmd=~/^GetLimitMaximum$/)	      {$rt=$::ChannelMax{mn2chX($target)};
	}elsif($cmd=~/^GetLimitMinimum$/)	      {$rt=$::ChannelMin{mn2chX($target)};
	}elsif($cmd=~/^SetLimitMaximum\s(-*\d+)$/){
		$::ChannelMax{mn2chX($target)}=$1;
		if($::SyncFailSafeWithLimit){$::FailSafeMax{mn2chX($target)}=$::ChannelMax{mn2chX($target)};}
		$rt='Ok:';
	}elsif($cmd=~/^SetLimitMinimum\s(-*\d+)$/){
		$::ChannelMin{mn2chX($target)}=$1;$rt='Ok:';
		if($::SyncFailSafeWithLimit){$::FailSafeMin{mn2chX($target)}=$::ChannelMin{mn2chX($target)};}
		$rt='Ok:';
	}elsif($cmd=~/^GetLimitStatus$/){
		$rt=M_GetLimitStatus($target);
		if($rt eq ''){
			return('N');
		}elsif($rt eq 1){
			return('+');
		}elsif($rt eq -1){
			return('-');
		}else{
			return('?');
		}
	}elsif($cmd=~/^GetFailSafeMaximum$/)	  {$rt=$::FailSafeMax{mn2chX($target)};
	}elsif($cmd=~/^GetFailSafeMinimum$/)  	  {$rt=$::FailSafeMin{mn2chX($target)};
	}elsif($cmd=~/^SetFailSafeMaximum\s(-*\d+)$/){$::FailSafeMax{mn2chX($target)}=$1;$rt='Ok:';
	}elsif($cmd=~/^SetFailSafeMinimum\s(-*\d+)$/){$::FailSafeMin{mn2chX($target)}=$1;$rt='Ok:';
	}elsif($cmd=~/^IsFailSafeStop$/)		  {$rt=$::FailSafeStop{mn2chX($target)};
#	}elsif($cmd=~/^GetJogPulse$/)		{$rt=1;
#	}elsif($cmd=~/^SetJogPulse\s(-*\d+)$/){$rt=1;
	}else{
		$::Error = "Bad command or parameter";
		if($::Debug){
			print "Motor $::Error:$from,$to,".num2name($target)
			 .",#$cmd#,#$rt#\n";
		}
	}
	return($rt);
}
###############################################################################
# Contoller Status
###############################################################################
sub interval{
	my($cur1,$cur2,$sendok,$stopmode,$isbusy)=C_GetFunctionStatus();
	intervalsync('System',0,$cur1,$cur2,$sendok,$stopmode,$isbusy);
}
sub intervalsync{
	my($to,$force,$cur1,$cur2,$sendok,$stopmode,$isbusy)=@_;
	my($ch0,$ch1)=(mn2chX(0),mn2chX(1));
	my($dir0,$dir1)=($cur1-$::Current{$ch0},$cur2-$::Current{$ch1});
if($::Debug){
print "$to,$force,$cur1,$cur2,$sendok,$stopmode,$isbusy\n";
print "INT;$::Interval_Time isbusy:$isbusy $::Current{'A'} $::Current{'B'} $cur1 $cur2\n";
print "INT;$::IsScanHome $::IsScanHomeManual $dir0 $dir1\n";
}
	if($isbusy=~/^[RB]$/){
		if($::IsNoReply){
			$::tak->Send("$::NodeName>System _Reconnected");
		}
		$::IsNoReply=0;
	}else{
		if(!($::IsNoReply)){
			$::tak->Send("$::NodeName>System _ErrorNoReply");
		}
		$::IsNoReply=1;
		$::Error = "No reply.";
		print "Internal Er: $::Error [$::NodeName]\n";
		return('');
	}
	# ChangedBusy 1->0
	if($::Interval_Time == INTERVAL_RUN){if($isbusy eq 'R'){$::Buf_Interval=0;}}

	if(($stopmode=~/[LW]/)){
if($::Debug){
print "INT2;$::Interval_Time flg:$::Flg_LimitSwitchOn{$ch0} isbusy:$isbusy $::Current{'A'} $::Current{'B'} $cur1 $cur2\n";
}
		if($::Flg_LimitSwitchOn{$ch0} eq ''){
			$::tak->Send("$::NodeName.".num2name(0).">$to _ChangedIsLimit 1");
			if($::Current{$ch0} eq ''){
				$::Flg_LimitSwitchOn{$ch0}=0;
			}elsif($::Current{$ch0} < $cur1){
				$::Flg_LimitSwitchOn{$ch0}=1;
			}elsif($::Current{$ch0} > $cur1){
				$::Flg_LimitSwitchOn{$ch0}=-1;
			}else{
				$::Flg_LimitSwitchOn{$ch0}=0;
			}
		}
		$::Buf_Interval=0;
	}
	
	if(($stopmode=~/[MW]/)){
if($::Debug){
print "INT3;$::Interval_Time flg:$::Flg_LimitSwitchOn{$ch1} isbusy:$isbusy $::Current{'A'} $::Current{'B'} $cur1 $cur2\n";
}
		if($::Flg_LimitSwitchOn{$ch1} eq ''){
			$::tak->Send("$::NodeName.".num2name(1).">$to _ChangedIsLimit 1");
			if($::Current{$ch1} eq ''){
				$::Flg_LimitSwitchOn{$ch1}=0;
			}elsif($::Current{$ch1} < $cur2){
				$::Flg_LimitSwitchOn{$ch1}=1;
			}elsif($::Current{$ch1} > $cur2){
				$::Flg_LimitSwitchOn{$ch1}=-1;
			}else{
				$::Flg_LimitSwitchOn{$ch1}=0;
			}
		}
		$::Buf_Interval=0;
	}

	# Flush ChangedValue
	if($force or ($::Buf_Interval<=0)){
		if($force or ($::Current{$ch0} ne $cur1)){
			$::tak->Send("$::NodeName.".num2name(0).">$to _ChangedValue ".$cur1);
			$::Current{$ch0}=$cur1;
		}
		if($force or ($::Current{$ch1} ne $cur2)){
			$::tak->Send("$::NodeName.".num2name(1).">$to _ChangedValue ".$cur2);
			$::Current{$ch1}=$cur2;
		}
		$::Buf_Interval=int(REFRESH_RUN/INTERVAL_RUN);
	}
if($::Debug){
print "INT4;$::Interval_Time isbusy:$isbusy $::Current{'A'} $::Current{'B'} $cur1 $cur2\n";
}
	# Status Stop
	if($::Interval_Time == INTERVAL_STOP){
		# ChangedBusy 0->1 Detected Flush ChangedIsBusy 1
		if($isbusy eq 'B'){
			change_isbusy('W',1,$to);
			$::Interval_Time=INTERVAL_RUN;
			$::Buf_Interval=0;
		}
		return('Ok:');
	}
	# Status Run
	$::Buf_Interval--;
	# ChangedBusy 1->0 Detected Flush ChangedIsBusy 0
	if($isbusy eq 'R'){
		change_isbusy('W',0,$to);
		$::Interval_Time = INTERVAL_STOP;
		$::Buf_Interval = int(REFRESH_RUN/INTERVAL_RUN);
	}else{
		if(($stopmode=~/[K]/)){
		if($::Debug){
			print "INT5;K $::Flg_LimitSwitchOn{$ch0} $::Flg_LimitSwitchOn{$ch1}\n";
		}
			if(!($::Flg_LimitSwitchOn{$ch0} eq '')){
				if($::Flg_LimitSwitchOn{$ch0} eq 1){
					if($::Current{$ch0} > $cur1){C_ClearLimitFlg($ch0);}
				}elsif($::Flg_LimitSwitchOn{$ch0} eq -1){
					if($::Current{$ch0} < $cur1){C_ClearLimitFlg($ch0);}
				}elsif($::Flg_LimitSwitchOn{$ch0} eq 0){
					if($::Current{$ch0} ne $cur1){C_ClearLimitFlg($ch0);}
				}
			}
			if(!($::Flg_LimitSwitchOn{$ch1} eq '')){
				if($::Flg_LimitSwitchOn{$ch1} eq 1){
					if($::Current{$ch1} > $cur2){C_ClearLimitFlg($ch1);}
				}elsif($::Flg_LimitSwitchOn{$ch1} eq -1){
					if($::Current{$ch1} < $cur2){C_ClearLimitFlg($ch1);}
				}elsif($::Flg_LimitSwitchOn{$ch1} eq 0){
					if($::Current{$ch1} ne $cur2){C_ClearLimitFlg($ch1);}
				}
			}
		}
		if(($::IsScanHome eq 0) and ($::IsScanHomeManual eq 0)){
			if(($dir0>0) and ($::FailSafeMax{$ch0}<$::Current{$ch0})){
				
				unless($::FailSafeStop{$ch0}){
					$::tak->Send("$::NodeName.".num2name(0).">System _ErrorStop Failsafe limit ditected.");
				}
				#C_Stop_Emergency();
				$::FailSafeStop{$ch0}=1;
				C_Stop('W');
			}elsif(($dir0<0) and ($::FailSafeMin{$ch0}>$::Current{$ch0})){
				unless($::FailSafeStop{$ch0}){
					$::tak->Send("$::NodeName.".num2name(0).">System _ErrorStop Failsafe limit ditected.");
				}
				#C_Stop_Emergency();
				$::FailSafeStop{$ch0}=1;
				C_Stop('W');
			}
			if(($dir1>0) and ($::FailSafeMax{$ch1}<$::Current{$ch1})){
				unless($::FailSafeStop{$ch1}){
					$::tak->Send("$::NodeName.".num2name(1).">System _ErrorStop Failsafe limit ditected.");
				}
				#C_Stop_Emergency();
				$::FailSafeStop{$ch1}=1;
				C_Stop('W');
			}elsif(($dir1<0) and ($::FailSafeMin{$ch1}>$::Current{$ch1})){
				unless($::FailSafeStop{$ch1}){
					$::tak->Send("$::NodeName.".num2name(1).">System _ErrorStop Failsafe limit ditected.");
				}
				#C_Stop_Emergency();
				$::FailSafeStop{$ch1}=1;
				C_Stop('W');
			}
		}
	}
	return('Ok:');
}
#------------------------------------------------------------------------------
sub change_isbusy{
	my($chX,$busy,$to)=@_;if($to eq ''){$to='System';}
	my $i;
	if($chX eq 'W'){
		if($busy eq '1'){
			for($i=0;$i<=$#::InternalChannelName;$i++){
				$::Flg_Busy{$::InternalChannelName[$i]}=$i;
			}
		}elsif($busy eq '0'){
			for($i=0;$i<=$#::InternalChannelName;$i++){
				$::Flg_Busy{$::InternalChannelName[$i]}='';
			}
		}else{
			return(setinternalerror('change_isbusy',"busy=>$busy"));
		}
		for(my $i=0;$i<=$#::InternalChannelName;$i++){
			$::tak->Send("$::NodeName.".num2name($i).">$to _ChangedIsBusy $busy");
		}
	}else{
		for($i=0;$i<=$#::InternalChannelName;$i++){
			if($chX eq $::InternalChannelName[$i]){
				if($busy eq '1'){$::Flg_Busy{$chX}=$i;
				}elsif($busy eq '0'){$::Flg_Busy{$chX}='';
				}else{return(setinternalerror('change_isbusy',"busy=>$busy"));}
				$::tak->Send("$::NodeName.".num2name($i).">$to _ChangedIsBusy $busy");
				last;
			}
		}
		if($i>$#::InternalChannelName){
			return(setinternalerror('change_isbusy',"chX=>$chX"));
		}
	}
	if($busy eq '1'){
		$::Interval_Time = INTERVAL_RUN;$::Buf_Interval=0;
	}else{
		$::Interval_Time = INTERVAL_STOP;
		$::Buf_Interval=int(REFRESH_RUN/INTERVAL_RUN);
	}
	return('Ok:');
}
#------------------------------------------------------------------------------
sub C_GetFunctionStatus{ #Get Status LSStop/Current/Busy.
	unless(device_write('Q:')){return('');}
#	stars->Sleep(WAIT_MEMWRITE);
	unless($_=device_read()){return('');}
	unless($_=~ /^\s*([-]?)\s*([^\s,]+)\s*,\s*([-]?)\s*([^\s,]+)\s*,\s*([^\s,])\s*,\s*([^\s,])\s*,\s*([^\s,])\s*$/){
		$::Error="Imvalid reply. [functionstatus:$_]";return('');
	}
	%::FunctionParameters=();
	$::FunctionParameters{0}="$1$2";
	$::FunctionParameters{1}="$3$4";
	$::FunctionParameters{2}=$5;
	$::FunctionParameters{3}=$6;
	$::FunctionParameters{4}=$7;
	if(wantarray){
		return("$1$2","$3$4",$5,$6,$7);
	}
	return($_);
}
#------------------------------------------------------------------------------
sub sigma_flushdata{
	my $from=shift; unless($from){$from='System';}
	my($cur1,$cur2,$sendok,$stopmode,$isbusy)=C_GetFunctionStatus();
	$::tak->Send("$::NodeName.".num2name(0).">$from _ChangedValue ".$cur1);
	$::tak->Send("$::NodeName.".num2name(1).">$from _ChangedValue ".$cur2);
	if($isbusy=~/^R$/){
		$isbusy=0;
	}elsif($isbusy=~/^B$/){
		$isbusy=1;
	}else{
		$isbusy="";
	}
	$::tak->Send("$::NodeName.".num2name(0).">$from _ChangedIsBusy ".$isbusy);
	$::tak->Send("$::NodeName.".num2name(1).">$from _ChangedIsBusy ".$isbusy);
	return('Ok:');
}
#------------------------------------------------------------------------------
sub EnableInterval{$::Enableinterval=1;}
sub EnableIntervalRun {
	if($::Enableinterval){
		if($::Debug){print "intervalrun enabled\n";}
		intervalsync('System',0,$::FunctionParameters{0},$::FunctionParameters{1}
		,$::FunctionParameters{2},$::FunctionParameters{3},$::FunctionParameters{4});
	}
	$::Enableinterval=0;
}
#------------------------------------------------------------------------------
sub Count_Busy{
	my $cnt=0;
	foreach my $chX (@::InternalChannelName){
		if($::Flg_Busy{$chX} ne ''){$cnt++;}
	}
	return($cnt);
}
#------------------------------------------------------------------------------
sub C_GetValue{
	my($chX)=@_; my $chx=chX2x($chX);if($chx eq ''){return('');}
	my($cur1,$cur2,$status,$stop,$busy)=C_GetFunctionStatus();
	if($cur1 eq ''){$::Error="Invalid reply. [Current: $cur1,$cur2]";return('');}
	if($chx eq 1){return($cur1);}elsif($chx eq 2){return($cur2);}
	return(setinternalerror('C_GetValue',"chx=>$chx"));
}
sub C_IsBusy{
	my($chX)=@_;
	my($cur1,$cur2,$status,$stop,$busy)=C_GetFunctionStatus();
	if($busy eq 'B'){return(1);}elsif($busy eq 'R'){return(0);}
	$::Error="Invalid reply. [Busy: $busy]"; return('');	
}
sub C_ClearLimitFlg{
	my($chX)=shift;
	if($chX eq 'W'){
if($::Debug){print "Limit Clear $chX\n";}	
		foreach $_ (@::InternalChannelName){
if($::Debug){print "Limit Clear CH $_ $::Flg_LimitSwitchOn{$_}, ".num2name(chXmn2($_)),"\n";}	
			if($::Flg_LimitSwitchOn{$_} ne ''){
				$::tak->Send("$::NodeName.".num2name(chXmn2($_)).">System _ChangedIsLimit 0");
			}
			$::Flg_LimitSwitchOn{$_}='';
			if($::FailSafeStop{$_}){
				$::FailSafeStop{$_}=0;
			}
		}
	}else{
if($::Debug){print "Limit Clear $chX";}	
		if($::Flg_LimitSwitchOn{$chX} ne ''){
			$::tak->Send("$::NodeName.".num2name(chXmn2($chX)).">System _ChangedIsLimit 0");
		}
		$::Flg_LimitSwitchOn{$chX}='';
		if($::FailSafeStop{$chX}){
			$::FailSafeStop{$chX}=0;
		}
	}
}
sub C_IsLimit{
	my($chX,$sign)=@_;
if($::Debug){
print "C_Limit chx=>$chX, Flg=>$::Flg_LimitSwitchOn{$chX}, sign=>$sign";
}
	if($::Flg_LimitSwitchOn{$chX} eq ''){
		return(0);
	}elsif($::Flg_LimitSwitchOn{$chX} eq 1){
		if($sign eq '-'){
		}elsif(($sign eq '+') or ($sign>=0)){
			$::Error = "Cw limit detected.";return(1);
		}
		return(0);
	}elsif($::Flg_LimitSwitchOn{$chX} eq -1){
		if($sign eq '+'){
		}elsif(($sign eq '-') or ($sign<=0)){
			$::Error = "Ccw limit detected.";return(1);
		}
		return(0);
	}elsif($::Flg_LimitSwitchOn{$chX} eq '0'){
		$::Error = "Cw or Ccw limit detected. See controller and check monitor.";
		return(0);
	}
	return(setinternalerror('C_IsLimit',"chx=>$chX, Flg=>$::Flg_LimitSwitchOn{$chX}, sign=>$sign"));
}
sub C_GetLimitStatus{
	my($chX)=@_;
	return($::Flg_LimitSwitchOn{$chX});
}
sub M_GetLimitStatus{
	my($mn)=shift;
	return(C_GetLimitStatus(mn2chX($mn)));
}
sub C_SetForceLimitStatus{
	my($chX,$val)=@_;
	$::Flg_LimitSwitchOn{$chX}=$val;
	return();
}
#------------------------------------------------------------------------------
sub M_GetValue{return(C_GetValue(mn2chX(shift)));}
sub M_IsBusy{return(C_IsBusy(mn2chX(shift)));}
##############################################################################
# HoldOnOff Commands(C)
###############################################################################
sub C_SetHold{return(sigma_send(shift,'C',shift));}
sub M_SetHold{return(C_SetHold(mn2chX(shift),shift));}
##############################################################################
# Scan Commands(H/J)
###############################################################################
sub C_SetValue{
	my($chX,$val)=@_;
	my $cmd='A';
	my $param;
	my $busy=C_IsBusy($chX); if($busy eq ''){return('');}
	if($busy){$::Error="Busy.";return('');}
	
	$param=sigma_pulse($chX,$val,0);
	if($param eq ''){clear_syncrunbuffer();return('');}
	if(Is_Standby()){
		if($::SyncRunCommandBuffer eq ''){$::SyncRunCommandBuffer=$cmd;
		}else{
			unless($::SyncRunCommandBuffer eq $cmd){
				$::Error="Assigned command for 'SyncRun' differs from a previous one. Standby off now.";
				clear_syncrunbuffer();return('');
			}
		}
		$::SyncRunParameterBuffer{$chX}=$param;	return('Ok:');
	}else{
		unless(sigma_send($chX,$cmd,$param)){return('');}return('Ok:');
	}
}
sub C_SetValueREL{
	my($chX,$val)=@_;
	my $cmd='A';
	my $param;
	my $busy=C_IsBusy($chX); if($busy eq ''){return('');}
	if($busy){$::Error="Busy.";return('');}
	my $cur=C_GetValue($chX);
	if($cur eq ''){$::Error="Invalid reply. [Current: $cur]";return('');}
	$param=sigma_pulse($chX,$val,$cur);

	if($param eq ''){clear_syncrunbuffer();return('');}
	if(Is_Standby()){
		if($::SyncRunCommandBuffer eq ''){$::SyncRunCommandBuffer=$cmd;
		}else{
			unless($::SyncRunCommandBuffer eq $cmd){
				$::Error="Assigned command for 'SyncRun' differs from a previous one. Standby off now.";
				clear_syncrunbuffer();return('');
			}
		}
		$::SyncRunParameterBuffer{$chX}=$param;return('Ok:');
	}else{
		unless(sigma_send($chX,$cmd,$param)){return('');}return('Ok:');
	}
}
#-----------------------------------------------------------------------------
sub M_SetValue{return(C_SetValue(mn2chX(shift),shift));}
sub M_SetValueREL{return(C_SetValueREL(mn2chX(shift),shift));}
sub M_Jog{return(C_SetValueREL(mn2chX(shift),shift));}
##############################################################################
# Scan Commands(H/J)
##############################################################################
sub C_ScanHome{
	my($chX,$param)=@_;
	my $busy=C_IsBusy($chX); if($busy eq ''){return('');}
	my $cmd='H';
	if($busy){$::Error="Busy.";return('');}
#	if(C_IsLimit($chX,$param)){return('');}
	if(Is_Standby()){
		if($::SyncRunCommandBuffer eq ''){$::SyncRunCommandBuffer=$cmd;
		}else{
			unless($::SyncRunCommandBuffer eq $cmd){
				$::Error="Assigned command for 'SyncRun' differs from a previous one. Standby off now.";
				clear_syncrunbuffer();return('');
			}
		}
		for(my $i=0;$i<=$#::InternalChannelName;$i++){
			if($chX eq $::InternalChannelName[$i]){next;}
			if($::SyncRunParameterBuffer{$::InternalChannelName[$i]} eq ''){next;}
			unless($::SyncRunParameterBuffer{$::InternalChannelName[$i]} eq $param){
				$::Error="Assigned parameter for 'SyncRun' differs from a previous one. Standby off now.";
				clear_syncrunbuffer();return('');
			}
		}
		$::SyncRunParameterBuffer{$chX}=$param;	return('Ok:');
	}else{
		unless(sigma_send($chX,$cmd,$param)){return('');}return('Ok:');
	}
#	return(sigma_send(shift,'H',shift));
}
sub C_ScanConst{
	my($chX,$param)=@_;
	my $busy=C_IsBusy($chX); if($busy eq ''){return('');}
	my $cmd='J';
	if($busy){$::Error="Busy.";return('');}
#	if(C_IsLimit($chX,$param)){return('');}
	if(Is_Standby()){
		if($::SyncRunCommandBuffer eq ''){$::SyncRunCommandBuffer=$cmd;
		}else{
			unless($::SyncRunCommandBuffer eq $cmd){
				$::Error="Assigned command for 'SyncRun' differs from a previous one. Standby off now.";
				clear_syncrunbuffer();return('');
			}
		}
		$::SyncRunParameterBuffer{$chX}=$param;	return('Ok:');
	}else{
		unless(sigma_send($chX,$cmd,$param)){return('');}return('Ok:');
	}
#	return(sigma_send(shift,'J',shift));
}
#-----------------------------------------------------------------------------
sub M_ScanHome{return(C_ScanHome(mn2chX(shift),shift));}
sub M_ScanConst{return(C_ScanConst(mn2chX(shift),shift));}
##############################################################################
# Preset Commands(R)
##############################################################################
sub C_Preset{return(sigma_send(shift,'R',shift));}
sub M_Preset{return(C_Preset(mn2chX(shift),shift));}
##############################################################################
# Stop Commands(L/L:E)
##############################################################################
sub C_Stop_Emergency{return(sigma_sendemergencystop());}
sub C_Stop{return(sigma_send(shift,'L',''));}
sub M_Stop{return(C_Stop(mn2chX(shift)));}
##############################################################################
# Configuration Settings
##############################################################################
sub C_SetSpeedAccTime{
	my($chX,$low,$high,$rate)=@_;
	my $cmd='D';
	my $param=sigma_speedrate($chX,$low,$high,$rate);
	if($param eq ''){clear_syncrunbuffer();return('');}
	unless(sigma_send($chX,$cmd,$param)){return('');}return('Ok:');
}
sub M_SetSpeedAccTime{
	return(C_SetSpeedAccTime(mn2chX(shift),shift,shift,shift));
}
###############################################################################
# Control SyncRun
###############################################################################
sub clear_syncrunbuffer{
	$::CtlIsStandBy=0;
	$::SyncRunCommandBuffer='';
	%::SyncRunParameterBuffer=();
	foreach my $chX (@::InternalChannelName){
		$::SyncRunParameterBuffer{$chX}='';
	}
	return('Ok:');
}
#------------------------------------------------------------------------------
sub C_ShowSyncRunBuffer{
	my $buf="$::SyncRunCommandBuffer";
	foreach my $chX (@::InternalChannelName){
		$buf.=",$chX=>$::SyncRunParameterBuffer{$chX}";
	}
	return($buf);
}
#------------------------------------------------------------------------------
sub Is_Standby{
	return($::CtlIsStandBy);
}
#------------------------------------------------------------------------------
sub C_Standby{
	my $mode=shift;
	if($mode eq 1){
#		if(Is_Standby()){$::Error="Standby already.";return('');}
		clear_syncrunbuffer();
		if(Count_Busy()>0){$::Error="Busy.";return('');}
	}elsif($mode eq 0){
		clear_syncrunbuffer();
	}else{
		clear_syncrunbuffer();
		return(setinternalerror('C_Standby',"mode=>$mode"));
	}
	$::CtlIsStandBy=$mode;
	return('Ok:');
}
#------------------------------------------------------------------------------
sub C_SyncRun{
	if(Count_Busy()>0){clear_syncrunbuffer();$::Error="Busy.";return('');}
	my($cmd,$param,$paramcount)=($::SyncRunCommandBuffer,'',0);
	my($chX,$chx);
	
	unless($::CtlIsStandBy){
		clear_syncrunbuffer();$::Error="Standby off.";return('');
	}
	if($cmd eq ''){
		clear_syncrunbuffer();
		$::Error="No command assigned for 'SyncRun'.";return('');
	}
	my $paramH='';
	for(my $i=0;$i<=$#::InternalChannelName;$i++){
		$chX=$::InternalChannelName[$i];
		unless($::SyncRunParameterBuffer{$chX} eq ''){
			$chx=chX2x($chX);if($chx eq ''){clear_syncrunbuffer();return('');}
			$param=$param . $::SyncRunParameterBuffer{$chX};
			$paramcount++;
		}
		if($cmd eq 'H'){$paramH=$::SyncRunParameterBuffer{$chX};}
	}
	
	clear_syncrunbuffer();
	if($paramcount eq ($#::InternalChannelName+1)){
		if($cmd eq 'H'){$param=$paramH;}
		unless(sigma_send('W',$cmd,$param)){return('');}
	}elsif($paramcount eq 0){
		unless(sigma_send('W',$cmd,$param)){return('');}
	}else{
		$::Error="Invalid parameters assigned for 'SyncRun'. [parameter=>$param]";
		return('');
	}
	return('Ok:');
}
###############################################################################
# Device Commands
###############################################################################
sub sigma_issendok{
	my($status,$rt);
	if($::Test){return('Ok:');}
#	($rt,$_,$status,$_,$_)=C_GetFunctionStatus();
#	if($status eq 'K'){return('Ok:');}
	$rt=device_read();
	if($rt eq 'OK'){return('Ok:');}
	$::Error="Bad command or parameters.";return('');
}
#----------------------------------------------------------------
sub sigma_run{
	unless(device_write('G:')){return('');}
	unless(sigma_issendok()){return('');}
	return('Ok:');
}
#----------------------------------------------------------------
sub sigma_send{
	my($chX,$cmd,$param)=@_;
	my $chx=chX2x($chX);if($chx eq ''){return('');}
	# Orgsearch
	if($cmd=~/^[H]$/){
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
		if(($::Settings{'AutoHoldOnOff'.$chX})){
			unless(C_SetHold($chX,1) eq ''){return('');}
			stars->Sleep(WAIT_MEMWRITE_HOLD);
		}
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		unless(change_isbusy('W',1)){return('');}
#		unless(change_isbusy($chX,1)){return('');}
		C_ClearLimitFlg($chX);
		$::IsScanHome=0;
		if(($param eq '+') and ($::ScanHomeDirection>0)){
			$::IsScanHome=1;
		}elsif(($param eq '-') and ($::ScanHomeDirection<0)){
			$::IsScanHome=-1;
		}
	# Rel/Abs/Scan + Run
	}elsif($cmd=~/^[MJ]$/){
#		if(C_IsLimit($chX,$param)){return('');}
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
		if(($::Settings{'AutoHoldOnOff'.$chX})){
			unless(C_SetHold($chX,1) eq ''){return('');}
			stars->Sleep(WAIT_MEMWRITE_HOLD);
		}
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_run()){return('');}
		unless(change_isbusy('W',1)){return('');}
#		unless(change_isbusy($chX,1)){return('');}
		$::IsScanHome=0;
		C_ClearLimitFlg($chX);
	}elsif($cmd=~/^[A]$/){
#		if(C_IsLimit($chX,$param-$::Current{$chX})){return('');}
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
		if(($::Settings{'AutoHoldOnOff'.$chX})){
			unless(C_SetHold($chX,1) eq ''){return('');}
			stars->Sleep(WAIT_MEMWRITE_HOLD);
		}
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_run()){return('');}
		unless(change_isbusy('W',1)){return('');}
#		unless(change_isbusy($chX,1)){return('');}
		C_ClearLimitFlg($chX);
		$::IsScanHome=0;
	# Preset
	}elsif($cmd=~/^[R]$/){
		unless($param=~s/^0+$/0/){
			C_Standby(0);
			$::Error="Sorry. Only 0 is valid.";return('');
		}
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
#		unless(device_write("$cmd:$chx$param")){return('');}
		unless(device_write("$cmd:$chx")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		unless(change_isbusy('W',1)){return('');}
#		unless(change_isbusy($chX,1)){return('');}
		$::IsScanHome=0;
	# Holdonoff
	}elsif($cmd=~/^[C]$/){
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		$::IsScanHome=0;
	# Speedchange
	}elsif($cmd=~/^[D]$/){
		if(Is_Standby()){
			C_Standby(0);
			$::Error="Invalid while standby. Standby cancelled now.";
			return('');
		}
		if(C_IsBusy($chX)){$::Error = "Busy.";return('');}
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		$::IsScanHome=0;
	# Stop
	}elsif($cmd=~/^[L]$/){
		C_Standby(0);
		unless(device_write("$cmd:$chx$param")){return('');}
		stars->Sleep(WAIT_MEMWRITE);
		unless(sigma_issendok()){return('');}
		$::IsScanHome=0;
	}else{
		$::Error="Internal error.[command:$cmd]";return('');
	}
	return('Ok:');
}
#----------------------------------------------------------------
sub sigma_sendemergencystop{
	C_Standby(0);
	unless(device_write("L:E")){return('');}
	stars->Sleep(WAIT_MEMWRITE);
	unless(sigma_issendok()){return('');}
	return('Ok:');
}
#----------------------------------------------------------------
sub sigma_pulse{
	my($chX,$pulse,$current)=@_;
	$pulse=$current+$pulse;

if($::Debug){
	print "sigma_pulse $chX, $pulse,$current,$::ChannelMin{$chX},$::ChannelMax{$chX}\n";
}
	if(($pulse < $::ChannelMin{$chX}) and ($pulse <= $::Current{$chX})){
		$::Error="Data out of range.";return('');
	}
	if(($pulse > $::ChannelMax{$chX}) and ($pulse >= $::Current{$chX})){
		$::Error="Data out of range.";return('');
	}
	if(C_IsLimit($chX,$pulse-$::Current{$chX})){return('');}
	if($pulse < 0){
		$pulse=abs($pulse);
		return(sprintf("-P%d",$pulse));
	}else{
		return(sprintf("+P%d",$pulse));
	}
}
#----------------------------------------------------------------
sub sigma_speedrate{
	my($chX,$low,$high,$rate)=@_;
	if($::Debug){print "Low:$low,High:$high,Rate:$rate\n";}
	if(($low<1)||($low > 20000)){
		$::Error="Minimum speed is out of range.";return('');
	}
	if(($high<$low)||($high > 20000)){
		$::Error="Maximum speed is out of range.";return('');
	}
	if(($rate<0)||($rate > 5000)){
		$::Error="Accelarator time is out of range.";return('');
	}
	if(($low<50) and ($high>=200)){
		$::Error="Set more than 50 as minimum speed.";return('');
	}
	return(sprintf("S%dF%dR%d",$low,$high,$rate));
}
###############################################################################
# Motor Number/Name/Channel Converter
###############################################################################
sub name2num{
	my $mname=shift;
	if($::Debug){print "MotorName:",$mname,":",$::MotorName{$mname},"\n";}
	if(defined($::MotorName{$mname})){return($::MotorName{$mname});}
	$::Error = "Bad motor name.";return(-1);
}
sub num2name{
	my $mnum=shift;
	if($mnum>=0 and $mnum<=$#::InternalChannelName){return($::MotorName[$mnum]);}
	$::Error = "Bad motor number.";return('');
}
sub mn2chX{
	my($mn)=shift;
	if($::Debug){print "MotorNumber:",$mn,":",$::InternalChannelName[$mn],"\n";}
	if($mn>=0 and $mn<=$#::InternalChannelName){return($::InternalChannelName[$mn]);}
	$::Error="Bad motor number.";return('');
}
sub chXmn2{
	my($chX)=uc(shift);
	for(my $mn=0;$mn<=$#::InternalChannelName;$mn++){
		if($::InternalChannelName[$mn] eq $chX){return($mn);}
	}
	$::Error="Bad channel.";return('');
}
sub chX2x{
	my($chX)=uc(shift);
	if($chX eq 'W'){return($chX);}
	for(my $mn=0;$mn<=$#::InternalChannelName;$mn++){
		if($::InternalChannelName[$mn] eq $chX){return($mn+1);}
	}
	$::Error="Bad channel.";return('');
}
#----------------------------------------------------------------
sub setinternalerror{
	my($func,$msg)=(shift,shift);
	$::Error="Internal error. [$func:$msg]";
	return('');
}
#------------------------------------------------------------------------------
sub get_help_list{
	my $target = shift;
	my $cmd = shift;
	if($target eq 'Cntrl'){
		unless($cmd){return(join(" ", sort(keys(%::helpcntrl))));}
		unless(defined($::helpcntrl{$cmd})){
			$::Error = "Command \"$cmd\" not found.";
			return('');
		}
		return($::helpcntrl{$cmd});
	}else{
		unless($cmd){return(join(" ", sort(keys(%::helpmotor))));}
		unless(defined($::helpmotor{$cmd})){
			$::Error = "Command \"$cmd\" not found.";
			return('');
		}
		return($::helpmotor{$cmd});
	}
}

sub set_help_list{
	my $title='';
	my $titlenew;
	my $buf='';
	my $target='';
	while(<DATA>){
		if(/^(?:Usage|Event): (\w+)( |$)/){
			$titlenew = $1;
			if($title){
				$buf =~ s/\r//gm;
				$buf =~ s/\n/\\n/gm;
				if($target =~ /Motor/){
					$::helpmotor{$title} = $buf;
				}
				if($target =~ /Controller/){
					$::helpcntrl{$title} = $buf;
				}
				$buf = '';
			}
			$title = $1;
		}
		if(/Target: (.+)/){
			$target=$1;
			next;
		}
		$buf .= $_;
	}
	$buf =~ s/\r//gm;
	$buf =~ s/\n/\\n/gm;
	if($target =~ /Motor/){
		$::helpmotor{$title} = $buf;
	}
	if($target =~ /Controller/){
		$::helpcntrl{$title} = $buf;
	}
}

__DATA__
#STARS Commands
Usage: help [Commmand]
Target: Controller, Motor
    List commands or show usage (with "command")

Usage: hello
Target: Controller, Motor
    The client returns "@hello nice to meet you."

Usage: GetRomVersion
Target: Controller
    Get ROM-version of Connecting Device.

Usage: flushdata
Target: Controller
    Get all status and sends event messages to "System".

Usage: flushdatatome
Target: Controller
    Get all status and sends event messages to me.

#Status read

Usage: GetLimitMaximum MotorName|MotorNumber
Target: Controller
    Get CW software limit maximum of "MotorNumber" (0 to 1).

Usage: GetLimitMaximum
Target: Motor
    Get CW software limit maximum.

Usage: SetSpeedAccTime MotorName|MotorNumber ValueLowSpeed,ValueHighSpeed,ValueAccTime
Target: Controller
    Set "ValueLowSpeed" as low speed value of "MotorNumber" (0 to 1).
    Set "ValueHighSpeed" as high speed value of "MotorNumber" (0 to 1).
    Set "ValueAccTime" as accelerator rate value of "MotorNumber" (0 to 1).

Usage: SetSpeedAccTime ValueLowSpeed,ValueHighSpeed,ValueAccTime
Target: Motor
    Set "ValueLowSpeed" as low speed value of motor.
    Set "ValueHighSpeed" as high speed value of motor.
    Set "ValueAccTime" as accelerator rate value of motor.

Usage: GetLimitMinimum MotorName|MotorNumber
Target: Controller
    Get CCW software limit maximum of "MotorNumber" (0 to 1).

Usage: GetLimitMinimum
Target: Motor
    Get CCW software limit maximum.

Usage: GetFunctionStatus
Target: Controller
    Get current, busy status, way of stopped

Usage: GetValue MotorName|MotorNumber
Target: Controller
    Get postion data of MotorNumber (0 to 1).

Usage: GetValue
Target: Motor
    Get postion data.

Usage: IsBusy MotorName||MotorNumber
Target: Controller
    Check, is motor busy?

Usage: IsBusy
Target: Motor
    Check, is motor busy?

Usage: Standby
Target: Controller
    Standby motor(s). The "Standby" command is used for starting 2 motors at
    the same time with "SyncRun" command.

Usage: SyncRun
Target: Controller
    Start motor(s). The "SyncRun" command is used for starting 2 motors at
    the same time with "Standby" command.

Usage: GetMotorList
Target: Controller
    List motor names.

Usage: GetMotorName MotorNumber
Target: Controller
    Get motor name of "MotorNumber".

Usage: GetMotorNumber
Target: Motor
    Get motor number of "MotorName".

Usage: Preset MotorName|MotorNumber 0
Target: Controller
    Set motor position data of "MotorNumber" (0 to 1) into "0".

Usage: Preset 0
Target: Motor
    Set motor position data into "0".

Usage: SetHold MotorName|MotorNumber 1|0
Target: Controller
    Set hold (=1) or free (=0) motor on "MotorNumber" (0 to 1).

Usage: SetHold 1|0
Target: Motor
    Set hold (=1) or free (=0).

Usage: SetValue MotorName|MotorNumber Value
Target: Controller
    Move motor which is shown "MotorNumber" to "Value" absolutely.

Usage: SetValue Value
Target: Motor
    Move motor to "Value" absolutely.

Usage: SetValueREL MotorName|MotorNumber Value
Target: Controller
    Move motor which is shown "MotorNumber" to "Value" relatively.

Usage: SetValueREL Value
Target: Motor
    Move motor to "Value" relatively.

Usage: JogCw MotorName|MotorNumber
Target: Controller
    Send CW jog command to "MotorNumber" (0 to 1).

Usage: JogCw
Target: Motor
    Send CW jog command.

Usage: JogCcw MotorName|MotorNumber
Target: Controller
    Send CCW jog command to "MotorNumber" (0 to 1).

Usage: JogCcw
Target: Motor
    Send CCW jog command.

Usage: ScanCw MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CW" with scan mode.

Usage: ScanCw
Target: Motor
    Move "CW" direction with scan mode.

Usage: ScanCcw MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CCW" with scan mode.

Usage: ScanCcw
Target: Motor
    Move "CCW" direction with scan mode.

Usage: ScanCwConst MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CW" with
    constant scan mode.

Usage: ScanCwConst
Target: Motor
    Move "CW" direction with constant scan mode.

Usage: ScanCcwConst MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CCW" with
    constant scan mode.

Usage: ScanCcwConst
Target: Motor
    Move "CCW" direction with constant scan mode.

Usage: ScanCwHome MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CW" for finding
    home position.

Usage: ScanCwHome
Target: Motor
    Move "CW" direction for finding home position.

Usage: ScanCcwHome MotorName|MotorNumber
Target: Controller
    Move "MotorNumber" (0 to 1) to "CCW" for finding
    home position.

Usage: ScanCcwHome
Target: Motor
    Move "CCW" direction for finding home position.

Usage: Stop [MotorName|MotorNumber]
Target: Controller
    Stop motors(s) which shown "MotorNumber". If they are
    not specified, all motors will be stopped.

Usage: Stop
Target: Motor
    Stop motor.

Usage: StopEmergency
Target: Controller
    Make a sudden stop of all motors.

#Events
Event: _ChangedIsBusy Value
    _ChangedIsBusy event shows that the status of motor has been changed.
    1 is busy, 0 is free.

Event: _ChangedValue Value
    _ChangedValue event shows that the position of motor has been changed.

#Event: _ChangedFunctionStatus Value
#    _ChangedFunctionStatus event shows that the function status has been changed.
#	"Value" detail shown by command help "GetFunctionStatus".
